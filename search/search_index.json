{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Site for how-to material which is not specific to my homelab environment. Not a lot here yet.","title":"Public How-to Wiki"},{"location":"disable-files-might-be-harful/","text":"This error can happen when you mount a network drive in Windows 7/8/10 when you try to perform an operation on files or folders on the mounted drive. To disable, follow these instructions: Bring up the start menu Type Internet Options Open Internet Options Go to the Security tab Select Local intranet to modify LAN Network settings Click the Sites button Click Advanced on the window that opens up Here you add exceptions. You can either add the exact IP address of your file server (recommended) or add an exception for your entire LAN network. a. To add an exception that covers multiple hosts, use a star * wildcard. For 192.168.1.1/24 you would put 192.168.1.* After adding the server in this menu, click Close and click OK You will have to disconnect and reconnect to the file server before the trust is realized. Reference article on tekrevue.com","title":"Disable 'These Files Might Harm Your Computer'"},{"location":"excel-sort-ipv4/","text":"You can use the following formula to give sortable IPV4 addresses in Excel (or similar) =join(\".\", arrayformula(text(split(A2, \".\"), \"000\")))","title":"Excel sort ipv4"},{"location":"Development/clear-browser-cache/","text":"About Redirect Caching In the absense of cache control directives that specify otherwise, a 301 redirect defaults to being cached without any expiry date. That is, it will remain cached for as long as the browser's cache can accommodate it. It will be removed from the cache if you manually clear the cache, or if the cache entries are purged to make room for new ones. You can verify this at least in Firefox by going to about:cache and finding it under disk cache. It works this way in other browsers including Chrome and the Chromium based Edge, though they don't have an about:cache for inspecting the cache. In all browsers it is still possible to override this default behavior using caching directives, as described below: If you don't want the redirect to be cached This indefinite caching is only the default caching by these browsers in the absence of headers that specify otherwise. The logic is that you are specifying a \"permanent\" redirect and not giving them any other caching instructions, so they'll treat it as if you wanted it indefinitely cached. The browsers still honor the Cache-Control and Expires headers like with any other response, if they are specified. You can add headers such as Cache-Control: max-age=3600 or Expires: Thu, 01 Dec 2014 16:00:00 GMT to your 301 redirects. You could even add Cache-Control: no-cache so it won't be cached permanently by the browser or Cache-Control: no-store so it can't even be stored in temporary storage by the browser. Though, if you don't want your redirect to be permanent, it may be a better option to use a 302 or 307 redirect. Issuing a 301 redirect but marking it as non-cacheable is going against the spirit of what a 301 redirect is for, even though it is technically valid. YMMV, and you may find edge cases where it makes sense for a \"permanent\" redirect to have a time limit. Note that 302 and 307 redirects aren't cached by default by browsers. If you previously issued a 301 redirect but want to un-do that If people still have the cached 301 redirect in their browser they will continue to be taken to the target page regardless of whether the source page still has the redirect in place. Your options for fixing this include: A simple solution is to issue another redirect back again. If the browser is directed back to a same URL a second time during a redirect, it should fetch it from the origin again instead of redirecting again from cache, in an attempt to avoid a redirect loop. Comments on this answer indicate this now works in all major browsers - but there may be some minor browsers where it doesn't. If you don't have control over the site where the previous redirect target went to, then you are out of luck. Try and beg the site owner to redirect back to you. Prevention is better than cure - avoid a 301 redirect if you are not sure you want to permanently de-commission the old URL. Source: Thomas Rutter - Stack Overflow answer Clear a 301 Permanent Redirect If you accidentally send a 301 permanently moved redirect while developing (possibly redirecting localhost to a live site, or from http to https), you need to clear the cache to fix this issue. In a chromium browser, (Edge, Google Chrome) the easiest way to do this is as follows: Open a new tab Open the developer tools (CTRL+SHIFT+I) or (F12) Open the Network tab Check the box by \"Disable Cache\" In the address bar, put the location you need to visit (where you previous sent the 301 from) Visit the site It should load, ignoring the cached 301 response.","title":"Clear browser cache"},{"location":"Development/clear-browser-cache/#about-redirect-caching","text":"In the absense of cache control directives that specify otherwise, a 301 redirect defaults to being cached without any expiry date. That is, it will remain cached for as long as the browser's cache can accommodate it. It will be removed from the cache if you manually clear the cache, or if the cache entries are purged to make room for new ones. You can verify this at least in Firefox by going to about:cache and finding it under disk cache. It works this way in other browsers including Chrome and the Chromium based Edge, though they don't have an about:cache for inspecting the cache. In all browsers it is still possible to override this default behavior using caching directives, as described below:","title":"About Redirect Caching"},{"location":"Development/clear-browser-cache/#if-you-dont-want-the-redirect-to-be-cached","text":"This indefinite caching is only the default caching by these browsers in the absence of headers that specify otherwise. The logic is that you are specifying a \"permanent\" redirect and not giving them any other caching instructions, so they'll treat it as if you wanted it indefinitely cached. The browsers still honor the Cache-Control and Expires headers like with any other response, if they are specified. You can add headers such as Cache-Control: max-age=3600 or Expires: Thu, 01 Dec 2014 16:00:00 GMT to your 301 redirects. You could even add Cache-Control: no-cache so it won't be cached permanently by the browser or Cache-Control: no-store so it can't even be stored in temporary storage by the browser. Though, if you don't want your redirect to be permanent, it may be a better option to use a 302 or 307 redirect. Issuing a 301 redirect but marking it as non-cacheable is going against the spirit of what a 301 redirect is for, even though it is technically valid. YMMV, and you may find edge cases where it makes sense for a \"permanent\" redirect to have a time limit. Note that 302 and 307 redirects aren't cached by default by browsers.","title":"If you don't want the redirect to be cached"},{"location":"Development/clear-browser-cache/#if-you-previously-issued-a-301-redirect-but-want-to-un-do-that","text":"If people still have the cached 301 redirect in their browser they will continue to be taken to the target page regardless of whether the source page still has the redirect in place. Your options for fixing this include: A simple solution is to issue another redirect back again. If the browser is directed back to a same URL a second time during a redirect, it should fetch it from the origin again instead of redirecting again from cache, in an attempt to avoid a redirect loop. Comments on this answer indicate this now works in all major browsers - but there may be some minor browsers where it doesn't. If you don't have control over the site where the previous redirect target went to, then you are out of luck. Try and beg the site owner to redirect back to you. Prevention is better than cure - avoid a 301 redirect if you are not sure you want to permanently de-commission the old URL. Source: Thomas Rutter - Stack Overflow answer","title":"If you previously issued a 301 redirect but want to un-do that"},{"location":"Development/clear-browser-cache/#clear-a-301-permanent-redirect","text":"If you accidentally send a 301 permanently moved redirect while developing (possibly redirecting localhost to a live site, or from http to https), you need to clear the cache to fix this issue. In a chromium browser, (Edge, Google Chrome) the easiest way to do this is as follows: Open a new tab Open the developer tools (CTRL+SHIFT+I) or (F12) Open the Network tab Check the box by \"Disable Cache\" In the address bar, put the location you need to visit (where you previous sent the 301 from) Visit the site It should load, ignoring the cached 301 response.","title":"Clear a 301 Permanent Redirect"},{"location":"Home%20Assistant/docker-influxdb/","text":"For instructions setting up InfluxDB with Docker, see the setup section below . {% linkable_title Setting up InfluxDB %} These instructions require you to have docker installed. Create a persistent volume for influxdb to store its data: docker volume create influxdb-data Run the following command to start the InfluxDB container: docker run -d \\ --name=\"influxdb\" \\ --restart always \\ -p 8086:8086 \\ -v influxdb-data:/var/lib/influxdb \\ influxdb After the container has started, run the influx client: docker exec -it influxdb influx Create a new database for Home Assistant: CREATE DATABASE home_assistant exit Add InfluxDB to Home Assistant by putting the influxdb section into your configuration.yaml influxdb: host: YOUR_DOCKERHOST_IP By default, all entities and their states will get sent to influxdb. It may be in your best interest to limit which devices are sent. You can do this by whitelisting entities or domains with include or blacklisting entities or domains with exclude . For example, you may want to only have your sensors values sent to influxdb: influxdb: host: YOUR_DOCKERHOST_IP include: domains: - sensor Restart Home Assistant to have it try and connect to InfluxDB. Once it has restarted, if there were any problems with it connecting, there will be an error notification on your Home Assistant page.","title":"Docker influxdb"},{"location":"Home%20Assistant/docker-influxdb/#linkable_title-setting-up-influxdb","text":"These instructions require you to have docker installed. Create a persistent volume for influxdb to store its data: docker volume create influxdb-data Run the following command to start the InfluxDB container: docker run -d \\ --name=\"influxdb\" \\ --restart always \\ -p 8086:8086 \\ -v influxdb-data:/var/lib/influxdb \\ influxdb After the container has started, run the influx client: docker exec -it influxdb influx Create a new database for Home Assistant: CREATE DATABASE home_assistant exit Add InfluxDB to Home Assistant by putting the influxdb section into your configuration.yaml influxdb: host: YOUR_DOCKERHOST_IP By default, all entities and their states will get sent to influxdb. It may be in your best interest to limit which devices are sent. You can do this by whitelisting entities or domains with include or blacklisting entities or domains with exclude . For example, you may want to only have your sensors values sent to influxdb: influxdb: host: YOUR_DOCKERHOST_IP include: domains: - sensor Restart Home Assistant to have it try and connect to InfluxDB. Once it has restarted, if there were any problems with it connecting, there will be an error notification on your Home Assistant page.","title":"{% linkable_title Setting up InfluxDB %}"},{"location":"Home%20Assistant/imap-content-sensor/","text":"The IMAP content sensor seems to be a little finnicky when getting set up. The errors that show up are less than useful. Listed here are some things I ran into and how to fix them. Setting up with GMAIL If you have 2-Factor Auth set up, you need to use an app password . Setting up with AOL Mail Initially I had issues getting the sensor to work, even with the correcty IMAP server set and my username and password. There is an additional setting under your account settings in \"Security\" where you need to all less secure logins. Sensor unable to update I had an issue where the emails it was looking for did not have a subject. This caused the sensor to fail updating.","title":"IMAP Content Sensor"},{"location":"Home%20Assistant/imap-content-sensor/#setting-up-with-gmail","text":"If you have 2-Factor Auth set up, you need to use an app password .","title":"Setting up with GMAIL"},{"location":"Home%20Assistant/imap-content-sensor/#setting-up-with-aol-mail","text":"Initially I had issues getting the sensor to work, even with the correcty IMAP server set and my username and password. There is an additional setting under your account settings in \"Security\" where you need to all less secure logins.","title":"Setting up with AOL Mail"},{"location":"Home%20Assistant/imap-content-sensor/#sensor-unable-to-update","text":"I had an issue where the emails it was looking for did not have a subject. This caused the sensor to fail updating.","title":"Sensor unable to update"},{"location":"Linux/archive-subdirs/","text":"#/bin/bash DIRECTORY=/target/dir cd \"$DIRECTORY\" for dir in */ do base=$(basename \"$dir\") tar -czf \"${base}.tar.gz\" \"$dir\" done","title":"Script to Archive Subdirectories into Individual tar.gz files"},{"location":"Linux/dummy-files/","text":"Sometimes you may want to fill some directories with files to test acting on actual directories with files. Using bash you can easily do this (replace n with the number of files you want): If you want to create files in '.': touch file{001..n}.txt If you want to create files in all subdirectories: touch */file{001..n}.txt","title":"Creating multiple dummy files"}]}